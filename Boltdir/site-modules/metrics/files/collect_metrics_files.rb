#!/opt/puppetlabs/puppet/bin/ruby
# frozen_string_literal: true

require "optparse"
require "time"
require "tmpdir"
require "zlib"
require "minitar"

# This script is intended to be run on a puppet infrastructure node that had the puppet_metrics_collector
# module installed and running.  Given a time window it will collect the json files generated by the
# puppet_metrics_collector module and tar them into the tar file.  This includes jsons that are in tar
# files already.  Those will be extracted and included if they are in the time window.
# The long term use case is with puppet bolt. But it isn't ready yet.  Like this:
# bolt script run .../collect_metrics_files.rb -n mymaster -u root --no-host-key-check
# The same module that contains this script will in the future contain bolt plans which will not
# only run the script, but also bring back the resulting tar file.

# General namespace for metrics module
module Metrics
  # Main class for collecting metrics files into a tar file
  #
  # @author Randell Pelak
  #
  # @attr [integer] start_epoch Epoch seconds for the start of the collection window
  # @attr [integer] end_epoch Epoch seconds for the end of the collection window
  # @attr [string] metrics_dir The "output directory" of the metrics collector puppet module
  # @attr [string] output_dir The directory to place the tarfile in.
  # @attr [string] tar_file_name Name of the tar file to create with the metrics
  # @attr [boolean] verbose Verbose output
  # @attr [integer] poll_interval The "collection_frequency" of the metrics collector puppet module
  # @attr [integer] archive_interval The frequency of the *_metrics_dir cron job for the metrics
  #   collector module.  This is how often it tars up the json files.
  #
  class CollectMetricsFiles
    # Initialize class
    #
    # @author Randell Pelak
    #
    # @param [integer] start_epoch Epoch seconds for the start of the collection window
    # @param [integer] end_epoch Epoch seconds for the end of the collection window
    # @param [string] metrics_dir The "output directory" of the metrics collector puppet module
    # @param [string] output_dir The directory to place the tarfile in.
    # @param [string] tar_file_name Name of the tar file to create with the metrics
    # @param [boolean] verbose Verbose output
    # @param [integer] poll_interval The "collection_frequency" of the metrics collector puppet module
    # @param [integer] archive_interval The frequency of the *_metrics_dir cron job for the metrics
    #   collector module.  This is how often it tars up the json files.
    #
    # @return [void]
    #
    # @example
    #   initialize(start_epoch, end_epoch, metrics_dir, output_dir, tar_file_name,
    #              poll_interval, archive_interval, verbose)
    #
    # rubocop:disable Metrics/ParameterLists
    def initialize(start_epoch, end_epoch, metrics_dir, output_dir, tar_file_name,
                   poll_interval, archive_interval, verbose = false)
      @start_epoch = start_epoch
      @end_epoch = end_epoch
      @metrics_dir = metrics_dir
      @output_dir = output_dir
      @tar_file_name = tar_file_name
      @poll_interval = poll_interval
      @archive_interval = archive_interval
      @verbose = verbose

      @parent_staging_dir = Dir.mktmpdir
      @staging_dir = @parent_staging_dir + "/puppet_metrics_collector"
      FileUtils.mkdir_p(@staging_dir)
      puts "staging dir is #{@staging_dir}" if @verbose
    end
    # rubocop:enable Metrics/ParameterLists

    # Process the metrics dir, blindly assume any non-exempted dir is a valid service dir
    #
    # @author Randell Pelak
    #
    # @return [void]
    #
    # @example
    #   inspect_metrics_dir_for_service_dirs
    def inspect_metrics_dir_for_service_dirs
      metrics_dir_obj = Dir.open @metrics_dir
      metrics_dir_obj.each do |path|
        next if path =~ /^scripts$|^bin$|^\.$|^\.\.$/

        absolute_path = "#{metrics_dir_obj.path}/#{path}"
        service = path
        next unless File.directory? absolute_path

        inspect_service_dir_for_metrics_files(absolute_path, service)
      end
    end

    # Process potential service dirs or subdirs
    #
    # Uses recursion but doesn't care which subdir the files come from, they all go in the
    # same output service dir
    #
    # @author Randell Pelak
    #
    # @param [string] dir_path Service dir or subdir
    # @param [string] service name of the service the directory belongs to
    #
    # @return [void]
    #
    # @example
    #   inspect_service_dir_for_metrics_files(dir_path, service)
    def inspect_service_dir_for_metrics_files(dir_path, service)
      service_dir = Dir.open dir_path
      service_dir.each do |path|
        next if path =~ /^\.$|^\.\.$/

        absolute_path = "#{service_dir.path}/#{path}"
        if File.directory?(absolute_path)
          inspect_service_dir_for_metrics_files(absolute_path, service)
          next
        end
        if path =~ /.json$/
          consider_json_for_inclusion(absolute_path)
        elsif path =~ /.tar.gz$/
          consider_tarfile_contents_for_inclusion(absolute_path, service)
        end
      end
    end

    # Determines if a json file is from the target window
    #
    # @author Randell Pelak
    #
    # @param [string] file_path path to json file
    #
    # @return [boolean] true if yes, false if no
    #
    # @example
    #   json_file_from_target_window?(file_path)
    def json_file_from_target_window?(file_path)
      raise ArgumentError, "Argument is not a json filename: #{file_path}" unless file_path.match(/\.json$/i)

      time_str = File.basename(file_path, ".json")
      time_obj = DateTime.parse(time_str)
      epoch = time_obj.to_time.to_i
      return epoch > @start_epoch && (epoch - @poll_interval) < @end_epoch
    end

    # Determines if a json file is from the target window and if so, stages it to the staging_dir
    #
    # @author Randell Pelak
    #
    # @param [string] file_path absolute path to json file
    #
    # @return [void]
    #
    # @example
    #   consider_json_for_inclusion(file_path)
    def consider_json_for_inclusion(file_path)
      stage_json(file_path) if json_file_from_target_window?(file_path)
    end

    # Stage json to the output_dir
    #
    # @author Randell Pelak
    #
    # @param [string] file_path absolute path to json file
    #
    # @return [void]
    #
    # @example
    #   stage_json(file_path)
    def stage_json(file_path)
      file_dir, filename = File.split(file_path)
      relative_dir_path = file_dir.gsub(%r{^#{@metrics_dir}/}, "")
      destination_dir = "#{@staging_dir}/#{relative_dir_path}"
      FileUtils.mkdir_p(destination_dir) unless File.directory?(destination_dir)
      FileUtils.cp(file_path, "#{destination_dir}/#{filename}")
    end

    # Determines if a tar file contains jsons from the target window and if so,
    # either copies the whole tar file, or extracts the jsons from it to copy the relevant ones to
    # the output_dir
    #
    # @author Randell Pelak
    #
    # @param [string] file_path absolute path to tar file
    # @param [string] service name of the service the file comes from
    #
    # @return [void]
    #
    # @example
    #   consider_tarfile_contents_for_inclusion(file_path, service)
    def consider_tarfile_contents_for_inclusion(file_path, service)
      filename = File.basename(file_path)
      return unless tarfile_from_target_window?(filename, service)

      # this is only here because without it the script doesn't output much and might appear to be hung
      puts "Checking #{filename} for relevant jsons"
      zip_reader = Zlib::GzipReader.new(File.open(file_path, "rb"))
      mtr = Archive::Tar::Minitar::Reader.new(zip_reader)
      jsons_to_include = []
      mtr.each do |file|
        jsons_to_include << file.full_name if json_file_from_target_window?(file.full_name)
      end
      return if jsons_to_include.empty?

      stage_jsons_from_tarfile(file_path, jsons_to_include, service)
    end

    # Stage the specific jsons from the tarfile to the staging area
    #
    # @author Randell Pelak
    #
    # @param [string] file_path absolute path to tar file
    # @param [array]  jsons_to_stage json files to stage
    # @param [string] service name of the service the file comes from
    #
    # @return void
    #
    # @example
    #   stage_jsons_from_tarfile(file_path, jsons_to_stage, service)
    def stage_jsons_from_tarfile(file_path, jsons_to_stage, service)
      zip_reader = Zlib::GzipReader.new(File.open(file_path, "rb"))
      service_staging_dir = "#{@staging_dir}/#{service}"
      FileUtils.mkdir(service_staging_dir) unless File.directory?(service_staging_dir)
      Archive::Tar::Minitar.unpack(zip_reader, service_staging_dir, jsons_to_stage)
    end

    # Determines if the tarfile may contain json files from the target window
    #
    # @author Randell Pelak
    #
    # @param [string] file_path Path to tar file
    # @param [string] service name of the service the file comes from
    #
    # @return [boolean] true if yes, false if no
    #
    # @example
    #   tarfile_from_target_window?(file_path, service)
    def tarfile_from_target_window?(file_path, service)
      filename = File.basename(file_path, ".tar.gz")
      time_str = filename.gsub(/^#{service}-/, "")
      time_obj = DateTime.strptime(time_str, "%Y.%m.%d.%H.%M.%S")
      epoch = time_obj.to_time.to_i
      return epoch > @start_epoch && (epoch - @archive_interval) < @end_epoch
    end

    # Tars up the resulting metrics files for easy transport off the system
    #
    # @author Randell Pelak
    #
    # @return [void]
    #
    # @example
    #   tar_metrics_files
    def tar_metrics_files
      v = (@verbose ? "v" : "")
      comm = "tar cz#{v}f #{@output_dir}/#{@tar_file_name} -C #{@parent_staging_dir} ."
      puts "Tarring metrics with: #{comm}" if @verbose
      system(comm)
      puts "Created #{@output_dir}/#{@tar_file_name}"
    end
  end
end

if $PROGRAM_NAME == __FILE__

  END_EPOCH_DEFAULT = Time.now.to_i
  START_EPOCH_DEFAULT = END_EPOCH_DEFAULT - (8 * 60 * 60) # minus 8 hours
  # TODO: can we get this from the module, it is configurable
  METRICS_DIR_DEFAULT = "/opt/puppetlabs/puppet-metrics-collector"
  # TODO: can we get this from the module, it is configurable
  POLL_INTERVAL_DEFAULT = 60 * 5
  # archival runs at a random time between 12am and 3am.
  # But the random time should be static for a given service
  # TODO: can we get this from the module, it is configurable
  ARCHIVE_INTERVAL_DEFAULT = 60 * 60 * (24 + 0)
  OUTPUT_DIR_DEFAULT = "."

  # Built the default tar file name from the start and end times
  #
  # @author Randell Pelak
  #
  # @param [string] start_epoch epoch time for the start of the window
  # @param [string] end_epoch epoch time for the end of the window
  #
  # @return [string] Filename
  #
  # @example
  #   filename = build_default_tar_filename(start_epoch, end_epoch)
  def build_default_tar_filename(start_epoch, end_epoch)
    start_epoch_str = Time.at(start_epoch).strftime("%Y%m%dT%H%M%SZ")
    end_epoch_str = Time.at(end_epoch).strftime("%Y%m%dT%H%M%SZ")
    return "#{start_epoch_str}-#{end_epoch_str}.tar.gz"
  end

  TAR_FILE_NAME_DEFAULT = build_default_tar_filename(START_EPOCH_DEFAULT, END_EPOCH_DEFAULT)

  DESCRIPTION = <<~DESCRIPTION
    This script is designed to gather up the json files from the puppet_metrics_collector module
    within a specified time frame.  Going as far as opening up the daily tar files and extracting
    only the matching jsons.
  DESCRIPTION

  DEFAULTS = <<~DEFAULTS
    The following defaults values are used if the options are not specified:
      * start (-s, --start_epoch): Now minus 8 hours. Ex: #{START_EPOCH_DEFAULT}
      * end (-e, --end_epoch): Now. Ex: #{END_EPOCH_DEFAULT}
      * metrics_dir (-m, --metrics_dir): #{METRICS_DIR_DEFAULT}
      * output_dir (-o, --output_dir): #{OUTPUT_DIR_DEFAULT}
      * tar_file_name (-t, --tar_file_name): Built from start and end time. Ex: #{TAR_FILE_NAME_DEFAULT}
      * poll_interval (-p, --poll_interval): #{POLL_INTERVAL_DEFAULT}
      * archive_interval (-a, --archive_interval): #{ARCHIVE_INTERVAL_DEFAULT}
      * verbose (-v, --verbose): False
  DEFAULTS

  options = {}

  OptionParser.new do |opts|
    opts.banner = "Usage: collect_metrics_files.rb [options]"

    opts.on("-h", "--help", "Display the help text") do
      puts DESCRIPTION
      puts opts
      puts DEFAULTS
      exit
    end

    opts.on("-s", "--start_epoch seconds", Integer,
            "Epoch time (seconds) that marks the start of the collection window") do |start_epoch|
      options[:start_epoch] = start_epoch
    end
    opts.on("-e", "--end_epoch seconds", Integer,
            "Epoch time (seconds) that marks the end of the collection window") do |end_epoch|
      options[:end_epoch] = end_epoch
    end
    opts.on("-m", "--metrics_dir dir_path", String, "The puppet_metrics_collector output directory") do |metrics_dir|
      options[:metrics_dir] = metrics_dir
    end
    opts.on("-o", "--output_dir dir_path", String, "Directory to write the tar file into") do |output_dir|
      options[:output_dir] = output_dir
    end
    opts.on("-t", "--tar_file_name filename", String, "The name of the output tar file ") do |tar_file_name|
      options[:tar_file_name] = tar_file_name
    end
    opts.on("-p", "--poll_interval seconds", Integer,
            "The puppet_metrics_collector module polling interval") do |interval|
      options[:poll_interval] = interval
    end
    opts.on("-a", "--archive_interval seconds", Integer,
            "The puppet_metrics_collector module archiving interval") do |interval|
      options[:archive_interval] = interval
    end
    opts.on("-v", "--verbose", String, "Enable Verbose output") { options[:verbose] = true }
  end.parse!

  start_epoch = options[:start_epoch] || START_EPOCH_DEFAULT
  end_epoch = options[:end_epoch] || END_EPOCH_DEFAULT
  metrics_dir = options[:metrics_dir] || METRICS_DIR_DEFAULT
  output_dir = options[:output_dir] || OUTPUT_DIR_DEFAULT
  poll_interval = options[:poll_interval] || POLL_INTERVAL_DEFAULT
  archive_interval = options[:archive_interval] || ARCHIVE_INTERVAL_DEFAULT
  tar_file_name = options[:tar_file_name] || build_default_tar_filename(start_epoch, end_epoch)
  verbose = options[:verbose] || false

  tar_file_name += ".tar.gz" unless tar_file_name =~ /.tar.gz$/

  if verbose
    OPTION_SETTINGS = <<~SETTINGS
      The following are the resulting options settings:
        * start: #{start_epoch}
        * end: #{end_epoch}
        * metrics_dir: #{metrics_dir}
        * output_dir: #{output_dir}
        * tar_file_name: #{tar_file_name}
        * poll_interval: #{poll_interval}
        * archive_interval: #{archive_interval}
        * verbose: #{verbose}
    SETTINGS
    puts OPTION_SETTINGS
  end

  options_error = "Metrics directory doesn't exist: #{metrics_dir}"
  raise options_error unless File.directory?(metrics_dir)

  FileUtils.mkdir_p(output_dir) unless File.directory?(output_dir)

  obj = Metrics::CollectMetricsFiles.new(start_epoch, end_epoch, metrics_dir, output_dir, tar_file_name,
                                         poll_interval, archive_interval, verbose)
  obj.inspect_metrics_dir_for_service_dirs
  obj.tar_metrics_files
end
